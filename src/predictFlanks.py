#!/usr/bin/env python

import numpy as np
import pandas as pd
import argparse

import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.use('Agg')

from matplotlib import rcParams
rcParams['font.family'] = 'Arial'
rcParams['xtick.major.size'] = 0
rcParams['xtick.minor.size'] = 0
rcParams['ytick.major.size'] = 0
rcParams['ytick.minor.size'] = 0
Nlookup = {"A":0, "C":1, "G":2, "T":3}

def MSE(x, y):
    return np.sum((x - y)**2)/len(x)

N = ['A', 'C', 'G', 'T']

parser = argparse.ArgumentParser(description="Compare the observed enrichment of flanking bp to the enrichment that would be expected given the flanking contributions calculated under our alignment-based framework versus those that were calculated by BEESEM.")
parser.add_argument("hit_counts", help="Tab-delimited file containing sequences in the first column and counts accross peaks in the second")
parser.add_argument("genomic_counts", help="Tab-delimited file containing sequences in the first column and counts accross the genome in the second")
parser.add_argument("flank_ddG", help="Tab-delimited file provided by analyzeAlignedSELEX.py which provides flanking contributions for each core.")
parser.add_argument("core", help="Sequence of the core used for hit finding.")
parser.add_argument("left_BEESEM_pfm", help="PFM generated by PFM covering all positions of interest 5' of the core.")
parser.add_argument("left_flank_len", type=int, help="Number of bp to consider 5' of the core.")
parser.add_argument("right_BEESEM_pfm", help="PFM generated by PFM covering all positions of interest 3' of the core.")
parser.add_argument("right_flank_len", type=int, help="Number of bp to consider 3' of the core.")

args = parser.parse_args()
hitfile = args.hit_counts
bgfile = args.genomic_counts
ddGfile = args.flank_ddG
core = args.core
lbeesemfile = args.left_BEESEM_pfm
lflank = args.left_flank_len
rbeesemfile = args.right_BEESEM_pfm
rflank = args.right_flank_len

obs = pd.read_csv(hitfile, sep='\t', index_col=0).transpose()
obs /= obs.sum()

bg = pd.read_csv(bgfile, sep='\t', index_col=0).transpose()
bg /= bg.sum()

flankddG = pd.read_csv(ddGfile, sep='\t', index_col=0).loc[core]
flankddG = pd.DataFrame(flankddG.values.reshape(-1, 4), columns=N)
flankddG.index = list(range(int(-len(flankddG)/2), 0)) + list(range(1, int(len(flankddG)/2+1)))
flankddG = flankddG.loc[obs.columns].transpose()
selexE = np.exp(-flankddG)
selexE /= selexE.sum()

selexPred = bg * selexE
selexPred /= selexPred.sum()

beesemE = pd.read_csv(lbeesemfile, sep='\t', skiprows=1).transpose().iloc[:,:lflank]
if(rflank > 0):
    beesemE = pd.concat([beesemE, pd.read_csv(rbeesemfile, sep='\t', skiprows=1).transpose().iloc[:,-rflank:]], axis=1)
beesemE.columns = obs.columns
beesemE /= beesemE.sum()

beesemPred = bg * beesemE
beesemPred /= beesemPred.sum()

obs = np.log(obs)
selexPred = np.log(selexPred)
beesemPred = np.log(beesemPred)

x = np.corrcoef(obs.values.flatten(), selexPred.values.flatten())[0,1]
print(f'alignment-based: r =  {x}')
x = np.corrcoef(obs.values.flatten(), beesemPred.values.flatten())[0,1]
print(f'BEESEM-based: r = {x}')
x = MSE(obs.values.flatten(), selexPred.values.flatten())
print(f'alignment-based: MSE =  {x}')
x = MSE(obs.values.flatten(), beesemPred.values.flatten())
print(f'BEESEM-based: MSE = {x}')

matrix = np.array([obs.values.transpose().flatten(), selexPred.values.transpose().flatten(), beesemPred.values.transpose().flatten()])
vmin = -np.ceil(abs(np.min(matrix)*10))/10
vmax = -np.floor(abs(np.max(matrix)*10))/10

lFlankLen = np.sum(obs.columns < 0)
rFlankLen = np.sum(obs.columns > 0)

figsize = np.array(matrix.transpose().shape)/4
fig, ax = plt.subplots(figsize=figsize)
mat = ax.matshow(matrix, cmap='RdBu', aspect="auto", vmin = vmin, vmax = vmax)
ax.axvline(lFlankLen * 4 - 0.5, color='red', linewidth=2)

posLabels = ["âˆ’" + str(s) + "\n" + b if b == "C" else "\n" + b for b, s in zip(N*lFlankLen, np.repeat(np.arange(lFlankLen)[::-1] + 1, 4))]
posLabels += ["+" + str(s) + "\n" + b if b == "C" else "\n" + b for b, s in zip(N*rFlankLen, np.repeat(np.arange(rFlankLen) + 1, 4))]

ax.set_xticks(range(matrix.shape[1]))
ax.set_yticks(range(matrix.shape[0]))
ax.set_xticks(np.arange(matrix.shape[1]+1)[::4] - 0.5, minor=True)
ax.set_yticks(np.arange(matrix.shape[0]+1)[::len(matrix)] - 0.5, minor=True)
ax.set_xticklabels(posLabels, fontsize=14, rotation=0)
ax.set_yticklabels(['observed', 'alignment-based', 'BEESEM-based'], fontsize=14, rotation=0, fontname="Arial")
for edge, spine in ax.spines.items():
    spine.set_visible(False)
ax.grid(which="minor", color="black", linewidth=0.5)
ax.yaxis.set_label_position('right')
ax.set_ylabel('[ln($p$)]', fontsize=12, labelpad = 7)
ax.set_title(f"ChIP-exo {core} Flanking Preferences", fontsize=16, y=2)
cbar = plt.colorbar(mat, aspect=5, ticks = [vmin, vmax], pad=0.07)
cbar.outline.set_linewidth(0.3)
plt.savefig('predFlanks_' + core + ".png", bbox_inches="tight", pad_inches=0, dpi=600)
plt.close()
